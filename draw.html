<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Drawing Space – 筆 Brush (Smooth) + Chat</title>
<style>
  :root { color-scheme: dark; }
  body {
    margin:0; background:#0b0b0b; color:#eee;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    height:100vh; display:flex; flex-direction:column;
  }
  .wrap { display:flex; flex:1; flex-wrap:wrap; gap:12px; padding:12px; box-sizing:border-box; overflow:hidden; }
  .left { width:min(520px,100%); }
  #canvas {
    width:100%; aspect-ratio:3/4; background:#00142a; /* dark navy so white ink pops */
    border-radius:12px; touch-action:none;
    /* stop iPad text selection / callout */
    user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
  }
  .toolbar { display:flex; gap:8px; margin:10px 0; flex-wrap:wrap; }
  button { background:#222; color:#eee; border:1px solid #333; border-radius:10px; padding:8px 14px; font-size:16px; cursor:pointer; }
  .ink { width:20px; height:20px; border-radius:50%; border:2px solid #333; background:#eee; cursor:pointer; }
  .ink.s{width:10px;height:10px;} .ink.m{width:16px;height:16px;} .ink.l{width:24px;height:24px;} .ink.erase{background:#000;border-style:dashed;}
  .right { flex:1; min-width:280px; display:flex; flex-direction:column; height:100%; }
  .chat { flex:1; overflow-y:auto; background:#111; border:1px solid #222; border-radius:12px; padding:10px; }
  .msg { background:#1b1b1b; border-radius:12px; padding:8px 10px; margin-bottom:8px; }
  .msg small { opacity:.7; }
  #inputBar { display:flex; gap:8px; margin-top:10px; }
  #userInput { flex:1; min-width:0; background:#111; border:1px solid #222; border-radius:10px; color:#eee; padding:10px 12px; font-size:16px; }
  .modeTag { padding:4px 8px; border:1px solid #333; border-radius:8px; font-size:12px; opacity:.8 }
</style>
</head>
<body>
<div class="wrap">

  <div class="left">
    <canvas id="canvas"></canvas>

    <div class="toolbar">
      <span class="modeTag" id="modeLabel">Mode: ペン</span>
      <button id="penBtn">ペン</button>
      <button id="fudeBtn">筆</button>
      <div class="ink s" data-w="2" title="細"></div>
      <div class="ink m" data-w="6" title="中"></div>
      <div class="ink l" data-w="12" title="太"></div>
      <div class="ink erase" data-erase="1" title="消しゴム"></div>
    </div>

    <div class="toolbar">
      <button id="saveBtn">Save</button>
      <button id="redrawBtn">Redraw</button>
      <button id="aiBtn">AI mode</button>
    </div>
  </div>

  <div class="right">
    <div class="chat" id="chat"></div>
    <div id="inputBar">
      <input id="userInput" placeholder="Type your message here…" />
      <button id="sendBtn">Send</button>
    </div>
  </div>

</div>

<script src="https://unpkg.com/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
<script>
/* ---------- Retina-correct canvas sizing ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

function resizeCanvas(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const { width: cssW, height: cssH } = canvas.getBoundingClientRect();
  // Set internal pixel size to CSS * DPR
  canvas.width  = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
  // background
  ctx.fillStyle = '#00142a';
  ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);
}
new ResizeObserver(resizeCanvas).observe(canvas);
resizeCanvas();

/* ---------- Modes & Tools ---------- */
ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#fff'; ctx.lineWidth=6;

let drawing=false, erasing=false;
let penMode=true, fudeMode=false;
document.getElementById('penBtn').onclick=()=>setMode('pen');
document.getElementById('fudeBtn').onclick=()=>setMode('fude');
const modeLabel=document.getElementById('modeLabel');

function setMode(which){
  penMode = which==='pen';
  fudeMode = which==='fude';
  erasing=false;
  ctx.globalCompositeOperation='source-over';
  modeLabel.textContent = 'Mode: ' + (penMode ? 'ペン' : '筆');
}

function setInk(width, erase=false){
  erasing = erase;
  if (erasing){ penMode=true; fudeMode=false; modeLabel.textContent='Mode: 消しゴム'; }
  ctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
  if (!fudeMode) ctx.lineWidth = width || ctx.lineWidth;
  ctx.strokeStyle = erase ? 'rgba(0,0,0,1)' : '#fff';
}
document.querySelectorAll('.ink').forEach(el=>{
  el.onclick = () => el.dataset.erase ? setInk(ctx.lineWidth, true) : setInk(+el.dataset.w, false);
});

/* ---------- Pointer helpers ---------- */
function ptFromClient(x, y){
  const r = canvas.getBoundingClientRect();
  return { x: x - r.left, y: y - r.top }; // thanks to setTransform(dpr...) we can use CSS pixels directly
}

/* ---------- Smooth ペン (quadratic) ---------- */
let lastP=null, lastCtrl=null;
function penTo(p){
  if(!lastP){ lastP=p; lastCtrl=p; return; }
  const mid = { x:(lastP.x+p.x)/2, y:(lastP.y+p.y)/2 };
  ctx.beginPath();
  ctx.moveTo(lastP.x, lastP.y);
  ctx.quadraticCurveTo(lastP.x, lastP.y, mid.x, mid.y);
  ctx.stroke();
  lastP = p;
}

/* ---------- 筆 brush (pressure + speed + coalesced events) ---------- */
let lastTime=0, lastForFude=null, lastPressure=0.6;
const FUDE_BASE=14, FUDE_MIN=1.6, FUDE_SPACING=0.8, FUDE_SOFT=0.18;

function fudeStamp(x, y, r){
  ctx.save();
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle='#fff';
  ctx.shadowColor='#fff';
  ctx.shadowBlur=r*FUDE_SOFT;
  ctx.beginPath();
  ctx.arc(x, y, Math.max(FUDE_MIN, r), 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}
function fudeBetween(a, b, pressure, dt){
  const dx=b.x-a.x, dy=b.y-a.y;
  const dist=Math.hypot(dx,dy);
  const steps=Math.max(1, Math.floor(dist / FUDE_SPACING));
  const speed = dist / Math.max(1, dt);      // px/ms
  const pressureFactor = pressure>0 ? pressure : lastPressure;
  const speedFactor = 1/(1 + speed*10);      // faster → thinner
  for(let i=0;i<=steps;i++){
    const t=i/steps, x=a.x+dx*t, y=a.y+dy*t;
    const r = Math.max(FUDE_MIN, FUDE_BASE * pressureFactor * speedFactor);
    fudeStamp(x, y, r);
  }
  lastPressure = pressureFactor;
}

/* ---------- Drawing with Pointer Events + getCoalescedEvents ---------- */
canvas.addEventListener('pointerdown', (e)=>{
  canvas.setPointerCapture(e.pointerId);
  drawing=true;
  lastTime=performance.now();
  lastP = ptFromClient(e.clientX, e.clientY);
  lastForFude = lastP;
  if (fudeMode && !erasing){
    const p = e.pressure || (e.pointerType==='pen'?0.6:0.5);
    fudeStamp(lastP.x, lastP.y, Math.max(FUDE_MIN, FUDE_BASE*p));
  }
});
canvas.addEventListener('pointermove', (e)=>{
  if(!drawing) return;

  const events = typeof e.getCoalescedEvents==='function' ? e.getCoalescedEvents() : [e];
  for(const ev of events){
    const p = ptFromClient(ev.clientX, ev.clientY);
    if (erasing || penMode){
      penTo(p);
    } else if (fudeMode){
      const now=performance.now();
      const dt=now-lastTime; lastTime=now;
      const pr = (ev.pressure>0 ? ev.pressure : (ev.pointerType==='pen'?0.6:0.5));
      fudeBetween(lastForFude, p, pr, dt);
      lastForFude = p;
    }
  }
});
window.addEventListener('pointerup', ()=>{ drawing=false; lastP=null; lastForFude=null; });

/* ---------- Touch/Mouse fallback (rarely used on iPad with Pencil) ---------- */
canvas.addEventListener('touchstart', e=>{ if(drawing) return; const t=e.touches[0]; drawing=true; lastP=ptFromClient(t.clientX,t.clientY); lastForFude=lastP; lastTime=performance.now(); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchmove', e=>{ if(!drawing) return; const t=e.touches[0]; const p=ptFromClient(t.clientX,t.clientY); const now=performance.now(); const dt=now-lastTime; lastTime=now; (fudeMode&&!erasing)?fudeBetween(lastForFude,p,0.6,dt):penTo(p); lastForFude=p; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', ()=>{ drawing=false; lastP=null; lastForFude=null; }, {passive:false});

/* ---------- Buttons ---------- */
document.getElementById('redrawBtn').onclick=()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); resizeCanvas(); };
document.getElementById('saveBtn').onclick=()=>{ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download=`drawing_${Date.now()}.png`; a.click(); };

/* ---------- AI Mode (OCR + translate demo) ---------- */
document.getElementById('aiBtn').onclick=async()=>{
  const b=document.getElementById('aiBtn'); b.disabled=true; b.textContent='AI mode…';
  try{
    const worker=await Tesseract.createWorker('eng',1);
    await worker.loadLanguage('jpn'); await worker.initialize('eng+jpn');
    const {data}=await worker.recognize(canvas.toDataURL());
    const text=(data.text||'').trim(); await worker.terminate();
    if(!text){ pushMsg('🤖 No readable text found','system'); }
    else { pushMsg('📝 OCR\n'+text,'user'); const t=await translate(text,'en'); pushMsg('🌐 Translated\n'+t,'assistant'); ctx.clearRect(0,0,canvas.width,canvas.height); resizeCanvas(); }
  }catch(e){ pushMsg('OCR error: '+e,'system'); }
  b.disabled=false; b.textContent='AI mode';
};
async function translate(q,target='en'){
  try{
    const res=await fetch('https://libretranslate.com/translate',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({q,source:'auto',target})});
    const j=await res.json(); return j.translatedText||q;
  }catch{return q;}
}

/* ---------- Chat (demo) ---------- */
document.getElementById('sendBtn').onclick=async()=>{
  const input=document.getElementById('userInput'); const msg=input.value.trim(); if(!msg)return;
  pushMsg(msg,'user'); const reply=await fakeReply(msg); pushMsg(reply,'assistant'); input.value=''; input.focus();
};
async function fakeReply(m){
  if(/筆|fude/i.test(m)) return "筆はApple Pencilの圧力と速度で太さが変わります。";
  return "You said: " + m;
}
function pushMsg(content, role='assistant'){
  const chat=document.getElementById('chat');
  const div=document.createElement('div');
  div.className='msg';
  div.innerHTML=`<small>${role}</small><div>${escapeHtml(content).replace(/\n/g,'<br>')}</div>`;
  chat.appendChild(div); chat.scrollTop=chat.scrollHeight;
}
function escapeHtml(s){return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));}
</script>
</body>
</html>
