<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Gravity Field Visualization</title>
  <style>
    html, body { margin: 0; height: 100%; background:#000; }
    #app { position: fixed; inset: 0; }
    #msg { position: fixed; left: 0; right: 0; top: 0; padding: 10px 14px; color: #fff; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: rgba(0,0,0,.5); display:none; }
  </style>
</head>
<body>
  <div id="msg"></div>
  <div id="app"></div>

  <script type="module">
    // --- Import Three.js (module build) & OrbitControls (module) ---
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    const uiMsg = (t)=>{ const el=document.getElementById('msg'); el.textContent=t; el.style.display='block'; };

    // --- WebGL support check ---
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      uiMsg('WebGL が無効のようです。iOSの設定 > Safari > 進んだ機能 で WebGL/サイト越えトラッキングの設定をご確認ください。');
    }

    // --- Renderer ---
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x000000, 1);
    container.appendChild(renderer.domElement);

    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 3.5, 8);

    // --- Lights ---
    scene.add(new THREE.AmbientLight(0x202020));
    const key = new THREE.PointLight(0xffffff, 1.2, 0, 2);
    key.position.set(3, 4, 2);
    scene.add(key);
    const rim = new THREE.PointLight(0x88ccff, 0.6, 0, 2);
    rim.position.set(-4, -2, -3);
    scene.add(rim);

    // --- Core (central mass) ---
    const core = new THREE.Mesh(
      new THREE.SphereGeometry(1, 48, 48),
      new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.3, roughness: 0.2, emissive: 0x082244 })
    );
    scene.add(core);

    // --- Particle cloud (small masses) ---
    const particles = new THREE.InstancedMesh(
      new THREE.SphereGeometry(0.03, 8, 8),
      new THREE.MeshBasicMaterial({ color: 0xffffaa }),
      1000
    );
    const dummy = new THREE.Object3D();
    for (let i = 0; i < particles.count; i++) {
      const r = THREE.MathUtils.randFloat(2.0, 5.5);
      const a = Math.random() * Math.PI * 2; // azimuth
      const e = Math.acos(THREE.MathUtils.randFloatSpread(2)); // elevation-like distribution
      dummy.position.set(
        r * Math.sin(e) * Math.cos(a),
        r * Math.sin(e) * Math.sin(a),
        r * Math.cos(e)
      );
      dummy.updateMatrix();
      particles.setMatrixAt(i, dummy.matrix);
    }
    scene.add(particles);

    // --- Optional: simple field-line arrows around the core ---
    const arrowGroup = new THREE.Group();
    const dir = new THREE.Vector3();
    for (let i = 0; i < 24; i++) {
      const th = (i / 24) * Math.PI * 2;
      for (let j = 0; j < 6; j++) {
        const ph = (j / 6) * Math.PI;
        const x = 2.2 * Math.sin(ph) * Math.cos(th);
        const y = 2.2 * Math.sin(ph) * Math.sin(th);
        const z = 2.2 * Math.cos(ph);
        const from = new THREE.Vector3(x, y, z);
        dir.copy(from).multiplyScalar(-1).normalize(); // toward center
        const arrow = new THREE.ArrowHelper(dir, from, 0.8, 0x66ccff, 0.15, 0.08);
        arrowGroup.add(arrow);
      }
    }
    scene.add(arrowGroup);

    // --- Controls ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Animate ---
    let t = 0;
    function animate() {
      requestAnimationFrame(animate);
      t += 0.005;
      particles.rotation.y += 0.0015;
      particles.rotation.x += 0.0005;
      core.rotation.y -= 0.002;
      controls.update();
      renderer.render(scene, camera);
    }

    try {
      animate();
    } catch (e) {
      console.error(e);
      uiMsg('描画中にエラーが発生しました: ' + e.message);
    }
  </script>
</body>
</html>
